## Импорты

## Лекция: Импортирование в Python

Сегодня мы поговорим о важной теме в Python — импортировании модулей. Это ключевая часть работы с кодом, которая
позволяет нам организовывать и переиспользовать код в наших проектах.

В этой части лекции мы затронем:

1. Ключевые слова `from`, `import`, и `as`.
2. Абсолютные и относительные импорты.
3. Роль файлов `__init__.py`.
4. Специфичное значение конструкции `if __name__ == '__main__':`.

### Модули и пакеты

#### Модули

Модуль в Python — это файл, содержащий определения и инструкции Python. Модули позволяют организовывать код в логически
связные части, упрощая его поддержку и переиспользование. Каждый модуль имеет свой собственный пространственный
контекст, что позволяет избегать конфликтов имен.

#### Основные концепции:

1. **Модуль как файл:**
    - Любой файл с расширением `.py` является модулем.
    - Имя модуля соответствует имени файла.

   Например, файл `math_operations.py` является модулем `math_operations`.

2. **Определения в модуле:**
    - Модуль может содержать функции, классы, переменные, а также исполняемый код.

    ```python
    # math_operations.py
    
    def add(a, b):
        return a + b
    
    def subtract(a, b):
        return a - b
    
    pi = 3.14159
    ```

3. **Импортирование модулей:**
    - Вы можете импортировать модуль, используя ключевое слово `import`.

    ```python
    import math_operations
    
    print(math_operations.add(5, 3))  # Вывод: 8
    print(math_operations.pi)         # Вывод: 3.14159
    ```

4. **Использование ключевых слов `from` и `import`:**
    - Вы можете импортировать конкретные функции или переменные из модуля.

    ```python
    from math_operations import add, pi

    print(add(5, 3))  # Вывод: 8
    print(pi)         # Вывод: 3.14159
    ```

5. **Псевдонимы с использованием ключевого слова `as`:**
    - Вы можете использовать псевдонимы для импортированных модулей или их частей.

    ```python
    import math_operations as mo

    print(mo.add(5, 3))  # Вывод: 8
    ```

#### Пакеты в Python

Пакет в Python — это коллекция модулей, организованных в директорию, которая содержит файл `__init__.py`. Пакеты
позволяют создавать иерархию модулей, упрощая организацию больших проектов.

**Пример структуры пакета:**

```
project/
    ├── package/
    │   ├── __init__.py
    │   ├── module1.py
    │   └── module2.py
    └── main.py
```

В файле `__init__.py` можно инициализировать пакет и упростить импорт модулей (хотя это совершенно не обязательно):

```python
# package/__init__.py
from .module1 import function1
from .module2 import function2
```

Теперь вы можете импортировать функции напрямую из пакета:

```python
# main.py
from package import function1, function2

function1()
function2()
```

#### Важные моменты

1. **Повторное использование кода:**
    - Модули позволяют переиспользовать код в разных частях проекта или в других проектах.

2. **Организация кода:**
    - Модули и пакеты помогают структурировать проект, делая его более понятным и легким в поддержке.

3. **Разделение пространства имен:**
    - Каждый модуль имеет свое собственное пространство имен, что позволяет избегать конфликтов имен.

4. **Публичные и приватные части:**
    - В модуле можно указать, какие части должны быть доступны извне, а какие — нет. Для этого используется соглашение
      об именовании: имена, начинающиеся с одного подчеркивания `_`, считаются приватными.

    ```python
    # example.py
    def public_function():
        pass

    def _private_function():
        pass
    ```

## Чуток детальнее

### Ключевые слова `from`, `import`, и `as`

Python предоставляет несколько ключевых слов для импортирования модулей и их частей. Давайте рассмотрим их подробнее.

#### Ключевое слово `import`

Ключевое слово `import` используется для импортирования всего модуля. Когда вы импортируете модуль таким образом, вы
можете обращаться к его содержимому, используя точечную нотацию.

> Кроме вашего написанного кода, внутри python существуют сотни если не тысячи дополнительных модулей которые можно
> импортировать.

> Какие-то из них используются постоянно, какие-то вы не увидите никогда.

> Кроме того, можно установить еще тысячи, если не десятки тысяч готовых модулей, но об этом будет отдельная лекция

**Пример:**

```python
import math

print(math.sqrt(16))  # Вывод: 4.0
```

#### Ключевое слово `from`

Ключевое слово `from` используется для импортирования конкретных частей модуля. Это позволяет вам импортировать только
те функции, классы или переменные, которые вам нужны.

**Пример:**

```python
from math import sqrt

print(sqrt(16))  # Вывод: 4.0
```

#### Ключевое слово `as`

Ключевое слово `as` позволяет вам дать импортированному модулю или его части псевдоним. Это может быть полезно для
сокращения длинных имен или разрешения конфликтов имен (например, когда в разных модулях есть функции с одинаковыми
названиями).

**Пример:**

```python
import math as m

print(m.sqrt(16))  # Вывод: 4.0
```

Или в сочетании с `from`:

```python
from math import sqrt as square_root

print(square_root(16))  # Вывод: 4.0
```

### Абсолютные и относительные импорты

#### Абсолютные импорты

Абсолютные импорты — это способ импортирования модулей, используя полный путь к модулю от корневого пакета. Они делают
ваш код более читаемым и ясным.

**Пример:**

Предположим, у нас есть следующая структура каталогов:

```
project/
    ├── main.py
    ├── package_a/
    │   └── __init__.py
    │   └── foo.py
    └── package_b/
        └── __init__.py
        └── bar.py
```

В файле `foo.py` мы можем импортировать функцию из `bar.py` таким образом:

```python
# module_a/foo.py
from package_b.bar import some_function
```

В этом примере мы используем абсолютный импорт, указывая полный путь от корня проекта (`package_b.bar`).

#### Относительные импорты

Относительные импорты используются для импортирования модулей относительно текущего модуля или пакета. Это удобный
способ, когда нужно импортировать модули, находящиеся в том же пакете или соседних пакетах.

**Пример:**

В файле `foo.py`, чтобы импортировать модуль `bar` из того же пакета `package_a`, мы можем использовать относительный
импорт:

```python
# package_a/foo.py
from .bar import some_function
```

Здесь `.` означает текущий пакет. Для импорта модуля из родительского пакета используем `..`:

```python
# module_a/foo.py
from ..package_b.bar import some_function
```

### 3. Роль файлов `__init__.py`

Файлы `__init__.py` используются для обозначения директорий как пакетов Python. Эти файлы могут быть пустыми, но их
присутствие сигнализирует интерпретатору Python, что директория должна рассматриваться как пакет.

**Примеры использования `__init__.py`:**

- **Пустой `__init__.py`**: Простой способ указать, что директория является пакетом.
- **С кодом**: Вы можете включить код в `__init__.py`, чтобы инициализировать пакет, настроить логирование или
  импортировать часто используемые подмодули:

```python
# module_a/__init__.py
from .foo import FooClass
from .bar import BarClass
```

Теперь при импорте `module_a` можно напрямую обращаться к `FooClass` и `BarClass`:

```python
from module_a import FooClass, BarClass
```

### 4. Специфичное значение конструкции `if __name__ == '__main__':`

В Python специальная переменная `__name__` содержит имя текущего модуля. Когда скрипт запускается как основная
программа, `__name__` имеет значение `'__main__'`. Это позволяет писать код, который будет выполняться только в случае,
если скрипт запущен напрямую, а не импортирован как модуль.

**Пример:**

Создадим файл `example.py`:

```python
# example.py
def main():
    print("Это главный скрипт.")


if __name__ == '__main__':
    main()
```

Если вы запустите `example.py`, вы увидите вывод "Это главный скрипт.". Но если вы импортируете этот файл как модуль в
другом скрипте:

```python
# another_script.py
import example
```

Никакой вывод не произойдет, так как `main()` не будет вызван.

> Используем для того что бы отделить между собой основной файл и второстепенные модули

## Про docstring и комментарии

Комментарии и строковые литералы документации (docstrings) являются важными инструментами для написания чистого и
понятного кода. Комментарии помогают другим разработчикам (и вам самим в будущем) понять, что делает конкретный фрагмент
кода, а docstrings служат для создания документации, объясняющей, как пользоваться функциями, классами и модулями.

### Комментарии в Python

Комментарии в Python начинаются с символа `#` и продолжаются до конца строки. Python интерпретирует эти строки как
комментарии и игнорирует их при выполнении кода.

**Пример использования комментариев:**

```python
# Это однострочный комментарий
x = 5  # Это комментарий после кода


# Следующий код вычисляет факториал числа
def factorial(n):
    # Инициализируем результат
    result = 1
    # Перебираем все числа от 1 до n
    for i in range(1, n + 1):
        result *= i
    return result
```

Комментарии помогают объяснить сложную логику, описать алгоритмы или просто напомнить о важных вещах.

### Многострочные комментарии

В Python нет синтаксической поддержки многострочных комментариев, как в некоторых других языках программирования.
Однако, для этого часто используют несколько однострочных комментариев:

**Пример многострочных комментариев:**

```python
# Это многострочный комментарий.
# Он используется для объяснения большого блока кода
# или сложного алгоритма.

x = 10
y = 20
z = x + y
```

### Строковые литералы документации (docstrings)

Docstrings - это строки, используемые для документирования модулей, классов, методов и функций. В отличие от обычных
комментариев, docstrings можно получить программно через атрибут `__doc__`.

**Пример использования docstring:**

```python
def add(a: int, b: int) -> int:
    """
    Возвращает сумму двух чисел.

    Аргументы:
    a -- первое число
    b -- второе число

    Возвращает:
    Сумма аргументов a и b.
    """
    return a + b


# Получение docstring
print(add.__doc__)
```

Этот docstring объясняет, что делает функция `add`, какие параметры она принимает и что возвращает.

### Docstrings для классов и модулей

Docstrings также используются для документирования классов и модулей.

**Пример docstring для класса:**

```python
class Dog:
    """
    Класс для представления собаки.

    Атрибуты:
    name (str) -- имя собаки
    age (int) -- возраст собаки

    Методы:
    bark() -- заставляет собаку лаять
    """

    def __init__(self, name: str, age: int):
        """
        Инициализирует объект Dog с именем и возрастом.

        Аргументы:
        name (str) -- имя собаки
        age (int) -- возраст собаки
        """
        self.name = name
        self.age = age

    def bark(self) -> str:
        """Заставляет собаку лаять."""
        return "Woof!"
```

**Пример docstring для модуля:**

```python
"""
Этот модуль предоставляет функции для работы с геометрическими фигурами.

Функции:
area_of_circle(radius) -- возвращает площадь круга с заданным радиусом
perimeter_of_square(side) -- возвращает периметр квадрата с заданной стороной
"""


def area_of_circle(radius: float) -> float:
    """Возвращает площадь круга с заданным радиусом."""
    from math import pi
    return pi * radius ** 2


def perimeter_of_square(side: float) -> float:
    """Возвращает периметр квадрата с заданной стороной."""
    return 4 * side
```

### Форматирование docstring

Существуют различные соглашения по форматированию docstring, включая стандарты Google, NumPy/SciPy и reStructuredText (
reST). Важно выбрать один стандарт и придерживаться его во всем проекте.

**Пример docstring в стиле Google:**

```python
def multiply(a: int | float, b: int | float) -> int | float:
    """
    Умножает два числа.

    Args:
        a (int, float): Первое число.
        b (int, float): Второе число.

    Returns:
        int, float: Произведение аргументов a и b.
    """
    return a * b
```

> Docstring как и типизации в современном мире считаются обязательным стандартом написания кода, и я ожидаю от вас
> использования их во всех домашках и модулях!

## PEP 8

PEP8 (Python Enhancement Proposal 8) – это руководство по стилю написания кода на Python. Соблюдение этого стандарта
помогает разработчикам создавать код, который легко читать и поддерживать. В этой лекции мы рассмотрим основные аспекты
PEP8, включая правила именования переменных, использование пробелов, составные инструкции, тернарный оператор и отступы
между функциями и классами.

### Именование переменных

#### Правильное именование

1. **Переменные и функции**:
    - Используйте стиль `snake_case` (слова разделяются нижним подчеркиванием).
    - Примеры:
      ```python
      user_name = "John"
      calculate_total()
      ```

2. **Классы**:
    - Используйте стиль `CamelCase` (каждое слово начинается с заглавной буквы).
    - Примеры:
      ```python
      class UserProfile:
          pass
      ```

#### Неправильное именование

- Избегайте использования стиля `camelCase` для функций и переменных.
- Избегайте слишком коротких или слишком длинных имен.
- Избегайте имен, состоящих из одного символа (например, `x`, `y`), если только это не циклические переменные или
  индексы.

### Использование пробелов

#### Пробелы вокруг операторов

- Добавляйте пробелы вокруг операторов присваивания (`=`), арифметических операторов (`+`, `-`, `*`, `/` и т.д.), а
  также вокруг операторов сравнения (`==`, `!=`, `<`, `>` и т.д.).
  ```python
  a = b + c
  if a == b:
      pass
  ```

#### Пробелы внутри скобок

- Не добавляйте пробелы внутри круглых, квадратных или фигурных скобок.
  ```python
  my_list = [1, 2, 3]
  function_call(a, b)
  ```

#### Пробелы перед запятыми и после запятых

- Не добавляйте пробелы перед запятыми.
- Добавляйте пробелы после запятых.
  ```python
  my_tuple = (1, 2, 3)
  ```

### Составные инструкции

Избегайте составных инструкций, когда несколько операторов записаны в одной строке.

#### Неправильно

```python
import os;import sys
```

#### Правильно

```python
import os
import sys
```

### Тернарный оператор

Тернарный оператор в Python используется для написания кратких условий. Он позволяет сократить код, записывая условие и
результат в одной строке.

#### Пример использования

```python
result = x if condition else y
```

#### Пример

```python
is_even = True if number % 2 == 0 else False
```

### Отступы между функциями и классами

Отступы между функциями и классами способствуют лучшей читаемости кода и разделению логических блоков.

#### Правила

1. **Отступы между методами внутри класса**:
    - Используйте один пустой ряд.
    - Пример:
      ```python
      class MyClass:
          def method_one(self):
              pass
 
          def method_two(self):
              pass
      ```

2. **Отступы между классами и функциями на верхнем уровне**:
    - Используйте два пустых ряда.
    - Пример:
      ```python
      class FirstClass:
          pass
 
 
      class SecondClass:
          pass
 
 
      def my_function():
          pass
      ```
      

В качестве домашки нужно ваш модуль разбить на небольшие логические куски.

Предполагаемая структура:
`main.py` - файл через который происходит запуск основной логики
`files.py` - файл куда надо переместить всю работу с файлами
`utils.py` - файл со всеми полезными функциями

